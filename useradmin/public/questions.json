[
  {
    "question": "Can you briefly introduce yourself and describe your experience with full-stack development, particularly using C# and React.js?",
    "answer": "Hello, my name is Avinash. I have around 2 years of experience working on various full-stack projects using technologies like .NET Core, C#, React.js, SQL Server, and MongoDB. I've been involved in backend API development, frontend integration, performance testing, and CI/CD automation. I'm passionate about building scalable, maintainable applications and have worked across all layers of the stack."
  },
  {
    "question": "The integration between the C# backend and the React.js frontend breaks after a recent code deployment. Outline your debugging process and how you ensure the fix maintains overall system integrity.",
    "answer": "Find the problem: I would check the web browser's developer console and the backend server logs for any error messages. Replicate: I would try to make the problem happen again in a test environment. Identify changes: I would look at the recent code that was deployed. Did an API name change? Was the data format changed? Fix and test: I would create a fix and run automated tests to make sure it works and doesn't break anything else. Deploy: I would push the fix to the staging environment for one last check before deploying it live."
  },
  {
    "question": "A critical piece of code needs to be hot-fixed in production. Detail your approach to resolving the issue using Github and deploying the fix with minimal downtime.",
    "answer": "Create a branch: I would immediately make a new branch in Github from the production code, called something like hotfix/login-bug. Write a small fix: I would make the simplest change possible to solve the bug. Test: I would test the fix on my local computer to make sure it works. Review and merge: I would get a teammate to quickly review the code, then merge it back into the production branch. Deploy with care: I would use a deployment method that replaces old servers one at a time, so the website stays online the whole time."
  },
  {
    "question": "Given this C# code snippet for a repository pattern, please explain what might be the issue with this implementation if we experience performance degradation over time.",
    "answer": "A common problem is that the code might be loading all data from a database table into memory. This works fine with a small amount of data, but as the table grows, it uses too much memory, slows down the server, and takes a long time to run. The solution: The code should be changed to: Only get a small 'page' of data at a time (pagination). Filter the data in the database before it's sent to the application."
  },
  {
    "question": "You're a database engineer working with a large e-Commerce SQL Server database. A business report that runs the following query is experiencing a performance issue. a) How would you investigate why this query is running slowly in SQL Server? b) What SQL Server-specific tools or techniques would you use? c) What indexing strategies, query changes, or other optimization techniques would you apply to improve its performance?",
    "answer": "a) How to investigate: I would look at the query's 'execution plan,' which shows me how SQL Server is running the query. I would look for steps that are taking a lot of time, like a 'Table Scan,' where the database has to read the entire table. b) Tools: I would use SQL Server Management Studio (SSMS) to get the execution plan. I might also use Query Store to see if the query's performance has gotten worse over time. c) Optimization: I would add indexes to the columns used in the WHERE clauses and JOINs. This is like adding an index to a book, so SQL Server can find the data it needs quickly without reading the whole table. I would also make sure the query only selects the columns it needs, instead of using SELECT *."
  }
]
